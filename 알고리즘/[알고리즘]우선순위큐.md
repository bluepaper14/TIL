# [알고리즘]우선순위큐

### 1-1  정의
우선순위 큐를 알기 위해서는 먼저 일반적인 큐 형태를 알아야한다. 큐는 FIFO 원칙을 따른다.(먼저 들어온 데이터가 먼저 나온다.) 하지만 우선순위 큐는 요소를 제거할떄 가장 높은 우선순위를 가진 요소가 먼저 나오도록 하는 자료구조이다. 기본적인 자료구조를 비교해보자.

| 자료구조 | 삭제되는 요소 |
| :---: | :---: |
| 스택 | 가장 최근에 들어온 데이터 |
| 큐 | 가장 먼저 들어온 데이터 | 
| 우선순위큐 | 가장 우선순위가 높은 데이터 |

**Q.그래서 큐와 우선순위큐의 차이점은?**
큐는 순서 기반, 우선순위 큐는 **중요도** 기반이다.
대표적으로 운영 체제에서의 작업 스케줄링,  최단 거리 알고리즘에서 주로 사용된다.

Q.왜 우선순위 큐가 가장 일반적인 큐라고 할 수 있는가?
왜냐하면 우선순위큐로 스택이나 큐도 우선순위큐로 구현할 수 있기 때문이다.

---
### 1-2  종류
우선순위 큐는 여러 가지 방법으로 구현이 가능한데, 여기서 가장 효율적인 구조는 히프(Heap)이다.

#### 배열
정렬이 되어 있지 않을때,
배열의 맨 끝에 새로운 요소를 추가하면 되므로, 삽입의 복잡도는 O(1)
하지만 정렬이 안되어 있으므로 삭제의 복잡도는 O(n)

정렬이 되어 있을때,
다른 요소와 비교하여 삽입위치를 결정해야한다.(빈자리를 만들고 삽입) 시간 복잡도는 O(n) 정렬되어 있으므로 삭제의 복잡도는 O(1)

#### 연결 리스트
정렬이 되어 있지 않을때,
포인터만 변경하면 되므로 삽입의 복잡도는 O(1)
삭제시 모든 노드를 뒤져야함으로 삭제의 복잡도는 O(n)

정렬이 되어 있을때,
삽입시 삽입위치를 찾아야함으로 삽입의 복잡도는  O(n)
삭제시, 첫번째 노드를 삭제하면 되므로 O(1)

#### 히프
히프는 완전 이진 트리의 일종, 완전히 정렬된 것은 아니지만 전혀 정렬이 안된 것도 아닌 상태를 유지한다.
삽입 복잡도는 O(logn)
삭제 복잡도는 O(logn)


히프의 목적은 여러개의 값들 중에서 최소값과 최대값을 찾기 위함이다.
즉, 부모노드가 자식 노드의 값보다 항상 큰 트리이다.
큰 값이 루트 노드에 있으므로 정렬도 필요X

**Key(부모노드) >= Key(자식노드)**

---
### 1-3  원리
히프는 완전이진트리이다. 그러므로 각 노드에 번호를 붙일 수 있는데, 해당 번호를 인덱스로 생각해서 히프의 노드들을 정렬한다.**그리고 배열의 첫 번째 인덱스인 0은 사용하지 않는다.**

![](https://velog.velcdn.com/images/bluepaper14/post/e914abb3-ebb9-4f3d-82df-87deaf13c718/image.jpg)
여기서 부모의 인덱스를 알고 있다면 해당 자식노드의 인덱스도 찾기 수월하다.

**왼쪽 자식의 인덱스 = 부모의 인덱스 * 2
오른쪽 자식의 인덱스 = (부모의 인덱스 * 2) + 1**

반대로 마찬가지다.
**부모의 인덱스 = (자식의 인덱스) / 2**(몫)

---
### 1-4  구현
```
typedef struct {
    int key;  // 힙에 저장되는 원소의 값
} element;
typedef struct {
    element heap[MAX_ELEMENT];  // 힙의 요소들을 저장하는 배열
    int heap_size;  // 현재 힙에 들어있는 원소의 개수
} HeapType;

```
히프에 새로운 요소가 들어오면, 먼저 히프의 마지막 노드로 삽입된다. 이후 새로운 노드를 부모 노드들과 교환하며 히프의 성질을 만족시킨다.
1)먼저 번호순으로 가장 마지막 위치에 이어서 새로운 노드가 삽입
2) 부모 노드와 비교하여 교환
3)이후 계속해서 비교
```
void insert_max_heap(HeapType* h, element item) {
    int i;
    i = ++(h->heap_size);  // 힙 크기를 먼저 증가시키고 그 인덱스를 i에 저장
                           // (이때 i는 삽입할 위치의 임시 값으로 사용)

    // 새로운 요소를 부모와 비교하며 위로 올라가면서 삽입할 위치를 찾음
    while ((i != 1) && item.key > h->heap[i / 2].key) {
        // i가 1이 아닐 때 (즉, 루트 노드가 아닐 때) 부모와 비교
        // 현재 노드의 key 값이 부모 노드의 key 값보다 크면
        // 부모 노드를 아래로 내림
        h->heap[i] = h->heap[i / 2];
        
        // 인덱스를 부모의 위치로 업데이트 (트리의 상위로 이동)
        i = i / 2;
    }
    
    // 위에서 반복문을 통해 부모보다 작은 위치까지 올라온 후
    // 최종적으로 현재 위치에 새로운 원소를 삽입
    h->heap[i] = item;
}

```
최대 히프에서 삭제 연산은 최대값을 가진 요소를 삭제하는 것이다. 최대값은 루트노드이므로 삭제 후 다시 재구성하는데,
1) 먼저 루트 노드가 삭제, 빈 루트 노드 자리에 히프의 마지막 노드를 가져옴
2) 새로운 루트와 자식노드를 비교하며 자식 노드가 크면 교환이 일어난다.
3) 이후 계속해서 비교한다.
```
element delete_max_heap(HeapType* h) {
    int parent, child;
    element item, temp;

    // 삭제할 루트 노드의 값을 저장 (최대값을 반환하기 위해)
    item = h->heap[1];

    // 힙의 마지막 노드를 임시로 저장
    temp = h->heap[h->heap_size--];  // 힙 크기를 하나 줄임

    // 루트에 마지막 노드를 넣고 아래로 내려가면서 제 위치를 찾음
    parent = 1;  // 시작은 루트에서
    child = 2;   // 왼쪽 자식

    while (child <= h->heap_size) {
        // 오른쪽 자식이 더 크면 오른쪽 자식으로 이동
        if ((child < h->heap_size) && (h->heap[child].key < h->heap[child + 1].key)) {
            child++;  // 오른쪽 자식 선택
        }

        // 부모 노드가 자식 노드보다 크면 멈춤
        if (temp.key >= h->heap[child].key) break;

        // 자식을 부모로 올림
        h->heap[parent] = h->heap[child];
        parent = child;  // 아래로 내려감
        child *= 2;      // 자식 노드의 왼쪽 자식으로 이동
    }

    // 찾은 위치에 마지막 노드 삽입
    h->heap[parent] = temp;

    // 삭제한 루트 노드 반환
    return item;
}

```
---
### 1-5 구현2
이후 히프를 이용하여 정렬도 가능하다. 
정렬해야할 n개의 요소들을 히프를 이용하여 삽입(정리)
이후 하나씩 노드를 히프에서 삭제하면서 저장
삽입 삭제의 복잡도는 O(logn)
요소의 개수가 n개 이므로 **삽입 복잡도는 O(nlogn)** -> 정렬이 빠른편

완전이진트리이기로 만들면 트리의 가장 낮은 높이의 트리가 만들어지기때문에
시간 복잡도는 O(logn)이 만들어진다. 

```
#include <stdio.h>
#define MAX_ELEMENT 200  // 힙의 최대 크기 정의

typedef struct {
    int key;  // 힙에 저장될 원소의 키 값
} element;

typedef struct {
    element heap[MAX_ELEMENT];  // 힙을 저장할 배열
    int heap_size;  // 현재 힙에 들어있는 원소의 개수
} HeapType;

// 힙 초기화 함수
void init(HeapType* h) {
    h->heap_size = 0;  // 힙의 크기를 0으로 초기화
}

// 최대 힙에 원소를 삽입하는 함수 (상향식 재구성)
void insert_max_heap(HeapType* h, element item) {
    int i;
    i = ++(h->heap_size);  // 새로운 원소를 삽입할 자리를 확보하고 힙 크기 증가
    while ((i != 1) && (item.key > h->heap[i / 2].key)) {  // 부모 노드보다 클 때까지 반복
        h->heap[i] = h->heap[i / 2];  // 부모 노드를 아래로 내림
        i /= 2;  // 부모 노드로 이동
    }
    h->heap[i] = item;  // 적절한 위치에 새로운 원소 삽입
}

// 최대 힙에서 최대 원소(루트)를 삭제하는 함수 (하향식 재구성)
element delete_max_heap(HeapType* h) {
    int parent, child;
    element item, temp;

    item = h->heap[1];  // 루트 노드(최대값)를 가져옴
    temp = h->heap[(h->heap_size)--];  // 마지막 노드를 루트로 올리고 힙 크기 감소
    parent = 1;  // 루트부터 시작
    child = 2;  // 왼쪽 자식 노드

    while (child <= h->heap_size) {  // 자식 노드가 힙 내에 있을 때까지 반복
        if ((child < h->heap_size) && (h->heap[child].key < h->heap[child + 1].key)) {
            child++;  // 오른쪽 자식이 더 크면 오른쪽 자식과 비교
        }
        if (temp.key >= h->heap[child].key) break;  // 자식이 더 작으면 반복 종료
        h->heap[parent] = h->heap[child];  // 자식을 부모 위치로 올림
        parent = child;  // 한 단계 아래로 이동
        child *= 2;  // 왼쪽 자식으로 이동
    }
    h->heap[parent] = temp;  // 마지막으로 가져온 원소를 적절한 위치에 삽입
    return item;  // 삭제된 루트 노드를 반환
}

// 힙 정렬 함수
void heap_sort(element a[], int n) {
    int i;
    HeapType h;

    init(&h);  // 힙 초기화

    // 주어진 배열을 힙에 삽입하여 최대 힙을 만듦
    for (i = 0; i < n; i++) {
        insert_max_heap(&h, a[i]);  // 배열의 각 원소를 힙에 삽입
    }

    // 힙에서 최대 원소를 하나씩 삭제하여 정렬
    for (i = (n - 1); i >= 0; i--) {
        a[i] = delete_max_heap(&h);  // 루트 노드를 배열에 저장 (내림차순 정렬)
    }
}

// 테스트를 위한 main 함수
int main() {
    element list[10] = { {10}, {30}, {40}, {60}, {90}, {70}, {20}, {50}, {80}, {100} };
    int n = 10;
    
    heap_sort(list, n);  // 힙 정렬 실행

    // 정렬 결과 출력
    for (int i = 0; i < n; i++) {
        printf("%d ", list[i].key);
    }

    return 0;
}

```
### 1-6 요약
- 우선순위큐 : 우선순위가 높은 노드가 먼저 삭제되는 큐
- MAX 힙 트리 : 부모 노드의 키값이 자식 노드의 키 값 보다 크거나 같은 완전이진트리
- 힙 트리를 배열 구조를 이용해서 구현
- 힙 트리의 성능 : 삽입/삭제 연산시 최악의 경우에도 O(logn)

---
[시험노트]
+ 중복되는 노드 관찰해보셈
+ 삭제하는 함수의 배열을 작성해보셈 -> 루트를 먼저 꺼낸 이후 전부 삭제
+ 삭제후 배열 삽입후 배열 값을 전부 쓸줄 알아야함
size temp item 에 뭐가 들어가는지 꼭 잘 봐야함(삭제의 개수에 따라 달라짐)
=item을 최종적으로 리턴
Max heap을 유지하되, 배열의 끝부터 채우기
+코드 조건 부분(3주차 숙지) 
